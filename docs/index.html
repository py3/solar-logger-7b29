<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="robots" content="noindex,nofollow" />
  <title>PV Logger Dashboard</title>
  <link rel="stylesheet" href="./style.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <header class="header">
    <div class="title">PV Logger</div>
    <div class="subtitle">最終更新: <span id="last-updated">—</span></div>
  </header>

  <main class="container">
    <section class="card">
      <div class="card-header">直近7日＋当日の時系列（kWh）</div>
      <canvas id="tsChart"></canvas>
      <div class="hint">グラフは 60 秒ごとに最新データへ更新します。データ: <code>/docs/data/pv_log.csv</code></div>
    </section>
  </main>

  <footer class="footer">© PV Logger</footer>

  <script>
    const CSV_PATH = './data/pv_log.csv';

    async function loadCsv() {
      const res = await fetch(CSV_PATH, { cache: 'no-store' });
      if (!res.ok) throw new Error('CSV fetch failed: ' + res.status);
      const text = await res.readable ? await res.text() : await res.text();
      const lines = text.trim().split(/\\r?\\n/);
      if (lines.length < 2) return { labels: [], series: {} };

      const header = lines.shift().split(',');
      const idx = {
        time: header.indexOf('page_time_jst'),
        gen:  header.indexOf('gen_kh') >= 0 ? header.indexOf('gen_kh') : header.indexOf('gen_kwh'),
        cons: header.indexOf('cons_kwh'),
        sell: header.indexOf('sell_kwh'),
        buy:  header.indexOf('buy_kwh'),
        self: header.indexOf('self_kwh')
      };

      const labels = [];
      const series = { '発電': [], '消費': [], '売電': [], '買電': [], '自家消費': [] };
      for (const line of lines) {
        const c = line.split(',');
        const t = c[idx.time];
        if (!t) continue;
        const toNum = v => {
          const n = Number(v);
          return Number.isFinite(n) ? n : null;
        };
        labels.push(t.replace('T', ' ').slice(0, 16));
        series['発電'].push(toNum(c[idx.gen]));
        series['消費'].push(toNum(c[idx.cons]));
        series['売電'].push(toNum(c[idx.sell]));
        series['買電'].push(toNum(c[idx.buy]));
        series['自家消費'].push(toNum(c[idx.self]));
      }
      return { labels, series };
    }

    function makeChart(ctx, payload) {
      const datasets = Object.entries(payload.series).map(([label, data]) => ({
        label, data, tension: 0.25, borderWidth: 2, pointRadius: 0
      }));
      return new Chart(ctx, {
        type: 'line',
        data: { labels: payload.labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'nearest', intersect: false },
          plugins: { legend: { position: 'bottom' } },
          scales: { x: { ticks: { maxTicksLimit: 12 } }, y: { beginAtZero: true } }
        }
      });
    }

    (async () => {
      try {
        const ctx = document.getElementById('tsChart').getContext('2d');
        const payload = await loadCsv();
        const chart = makeChart(ctx, payload);
        document.getElementById('last-updated').textContent =
          payload.labels[payload.labels.length - 1] || '—';

        // 60秒ごとに再読込
        setInterval(async () => {
          try {
            const p = await loadCsv();
            chart.data.labels = p.labels;
            chart.data.datasets = Object.entries(p.series).map(([label, data]) => ({
              label, data, tension: 0.25, pointRadius: 0, borderWidth: 2
            }));
            document.getElementById('last-updated').textContent =
              p.labels[p.labels.length - 1] || '—';
            chart.update();
          } catch (e) {
            console.error(e);
          }
        }, 60000);
      } catch (e) {
        console.error(e);
      }
    })();
  </script>
</body>
</html>
